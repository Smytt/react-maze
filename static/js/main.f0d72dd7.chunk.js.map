{"version":3,"sources":["types/index.ts","providers/SelectedCellsProvider.tsx","utils/index.ts","hooks/useMaze.ts","components/Cell.tsx","components/Maze.tsx","components/PickerCell.tsx","components/Error.tsx","components/MazePicker.tsx","components/MazeContainer.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Direction","PickerCell","SelectedCellsContext","createContext","SelectedCellsProvider","children","useState","points","setPoints","Provider","value","addPoint","point","newPoints","length","generateEmptyMaze","width","height","row","push","maze","generateCell","start","exit","previousCellDirection","y","x","directions","border","Up","Right","Down","Left","forEach","direction","openDirection","_","shuffle","useMaze","setMaze","useEffect","undefined","generateMaze","Cell","cell","borderStyle","borderLeftStyle","left","borderRightStyle","right","borderTopStyle","up","borderBottomStyle","down","className","style","Maze","mazeDimensions","margin","padding","map","clear","type","useContext","console","log","some","onClick","Error","message","Alert","color","MazePicker","outerMaze","setOuterMaze","i","PickerCellType","Corner","Opening","j","Filler","MazeContainer","App","setWidth","setHeight","setMazeDimensions","InputGroup","InputGroupAddon","addonType","InputGroupText","Input","onChange","e","target","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f0d72dd7.chunk.js","sourcesContent":["export interface Cell extends Point {\r\n  // isCorrectPath: boolean;\r\n  border: {\r\n    [key in Direction]: boolean\r\n  }\r\n}\r\n\r\nexport interface Point {\r\n  x: number,\r\n  y: number,\r\n  openDirection?: Direction\r\n}\r\n\r\nexport interface Dimensions {\r\n  width: number,\r\n  height: number\r\n}\r\n\r\nexport enum Direction { \r\n  Up = 'up', \r\n  Right = 'right', \r\n  Down = 'down', \r\n  Left = 'left' \r\n}\r\n\r\nexport enum PickerCell { \r\n  Opening = 'opening',\r\n  Corner = 'corner', \r\n  Filler = 'filler' \r\n}","import { createContext, useState } from \"react\";\r\nimport { Point } from \"../types\";\r\n\r\nexport const SelectedCellsContext = createContext<any>({})\r\n\r\nconst SelectedCellsProvider = ({ children }) => {\r\n  const [points, setPoints] = useState<Point[]>([])\r\n\r\n  const addPoint = (point: Point) => {\r\n    let newPoints; \r\n    if (points.length < 2) {\r\n      newPoints = [...points, point]\r\n    }\r\n    else {\r\n      newPoints = [points[1], point]\r\n    }\r\n    setPoints(newPoints)\r\n  }\r\n\r\n  return (\r\n    <SelectedCellsContext.Provider value={{ points, addPoint }} >\r\n      {children}\r\n    </SelectedCellsContext.Provider>\r\n  )\r\n}\r\n\r\nexport default SelectedCellsProvider","import _ from 'lodash';\r\nimport { Cell, Dimensions, Direction, Point } from \"../types\"\r\n\r\nexport const generateEmptyMaze = (width: number, height: number) => {\r\n  const row: Cell[] = []\r\n  while (row.length < width) {\r\n    row.push(null as unknown as Cell)\r\n  }\r\n  const maze: Cell[][] = []\r\n  while (maze.length < height) {\r\n    maze.push([...row])\r\n  }\r\n  return maze as Cell[][]\r\n}\r\n\r\nexport const generateMaze = (\r\n  width: number,\r\n  height: number,\r\n  start: Point,\r\n  exit: Point\r\n): Cell[][] => {\r\n  const maze = generateEmptyMaze(width, height)\r\n  generateCell(maze, start, start, exit, undefined)\r\n  return maze\r\n}\r\n\r\nexport const generateCell = (maze: Cell[][], point: Point, start: Point, exit: Point, previousCellDirection?: Direction) => {\r\n  if (maze[point.y][point.x]) {\r\n    return;\r\n  }\r\n\r\n  const directions: Direction[] = []\r\n  const border = {\r\n    [Direction.Up]: true,\r\n    [Direction.Right]: true,\r\n    [Direction.Down]: true,\r\n    [Direction.Left]: true\r\n  }\r\n\r\n  if (point.x + 1 < maze[0].length && !maze[point.y][point.x + 1]) {\r\n    directions.push(Direction.Right)\r\n  }\r\n\r\n  if (point.x > 0 && !maze[point.y][point.x - 1]) {\r\n    directions.push(Direction.Left)\r\n  }\r\n\r\n  if (point.y + 1 < maze.length && !maze[point.y + 1][point.x]) {\r\n    directions.push(Direction.Down)\r\n  }\r\n\r\n  if (point.y > 0 && !maze[point.y - 1][point.x]) {\r\n    directions.push(Direction.Up)\r\n  }\r\n\r\n  directions.forEach(direction => border[direction] = false);\r\n  if (previousCellDirection) border[previousCellDirection] = false;\r\n\r\n  if (point.x === start.x && point.y === start.y) {\r\n    border[start.openDirection!] = false;\r\n  }\r\n  if (point.x === exit.x && point.y === exit.y) {\r\n    border[exit.openDirection!] = false;\r\n  }\r\n\r\n  maze[point.y][point.x] = {\r\n    border,\r\n    ...point\r\n  }\r\n\r\n  const shuffledDirections = _.shuffle(directions)\r\n\r\n  shuffledDirections.forEach(direction => {\r\n    switch (direction) {\r\n      case Direction.Up: generateCell(maze, { x: point.x, y: point.y - 1 }, start, exit, Direction.Down); break;\r\n      case Direction.Right: generateCell(maze, { x: point.x + 1, y: point.y }, start, exit, Direction.Left); break;\r\n      case Direction.Down: generateCell(maze, { x: point.x, y: point.y + 1 }, start, exit, Direction.Up); break;\r\n      case Direction.Left: generateCell(maze, { x: point.x - 1, y: point.y }, start, exit, Direction.Right); break;\r\n      default: break;\r\n    }\r\n  })\r\n}","import { useEffect, useState } from \"react\"\r\nimport { Cell, Point } from \"../types\";\r\nimport { generateMaze } from \"../utils\";\r\n\r\nexport const useMaze = (\r\n  width: number,\r\n  height: number,\r\n  start: Point,\r\n  exit: Point,\r\n) => {\r\n  const [maze, setMaze] = useState<Cell[][]>([]);\r\n\r\n  useEffect(() => {\r\n    const maze = generateMaze(width, height, start, exit)\r\n    setMaze(maze)\r\n  }, [width, height, start, exit])\r\n\r\n  return [maze]\r\n}","import React from 'react';\r\nimport '../css/cell.css'\r\nimport { Cell as CellType } from '../types';\r\n\r\nconst Cell: React.FC<{ cell: CellType }> = ({ cell }) => {\r\n\r\n  const borderStyle: React.CSSProperties = {\r\n    borderLeftStyle: cell.border.left ? 'solid' : 'none',\r\n    borderRightStyle: cell.border.right ? 'solid' : 'none',\r\n    borderTopStyle: cell.border.up ? 'solid' : 'none',\r\n    borderBottomStyle: cell.border.down ? 'solid' : 'none',\r\n }\r\n\r\n  return (\r\n    <div className=\"cell\" style={borderStyle}>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Cell;","import { useMaze } from \"../hooks/useMaze\";\r\nimport Cell from \"./Cell\";\r\n\r\nconst Maze: React.FC<any> = ({ mazeDimensions, start, exit }) => {\r\n\r\n  const [maze] = useMaze(mazeDimensions.width, mazeDimensions.height, start, exit)\r\n\r\n  return (\r\n    <div style={{ width: `${(mazeDimensions!.width + 2) * 23}px`, margin: '0 auto' }}>\r\n      <div style={{ padding: '23px' }}>\r\n        {\r\n          maze.map(row =>\r\n            <div style={{ clear: 'both' }}>\r\n              {\r\n                row.map(cell => <Cell {...{ cell }} />)\r\n              }\r\n            </div>\r\n          )\r\n        }\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Maze;","import _ from 'lodash';\r\nimport { Direction, PickerCell as PickerCellType, Point } from \"../types\"\r\nimport '../css/cell.css'\r\nimport { useContext } from \"react\"\r\nimport { SelectedCellsContext } from \"../providers/SelectedCellsProvider\"\r\n\r\nconst PickerCell: React.FC<Props> = ({ type, point }) => {\r\n\r\n  const { points, addPoint } = useContext(SelectedCellsContext)\r\n\r\n  console.log('point')\r\n\r\n  const selectCell = () => {\r\n    addPoint(point)\r\n  }\r\n\r\n  return (\r\n    <div className={`cell ${type} ${_.some(points, point) ? 'selected' : ''}`} onClick={selectCell}>\r\n    </div>\r\n  )\r\n}\r\n\r\ninterface Props {\r\n  type: PickerCellType,\r\n  point?: Point,\r\n}\r\n\r\nexport default PickerCell","import { Alert } from 'reactstrap';\r\n\r\nconst Error: React.FC<Props> = ({ message }) => {\r\n  return (\r\n    <div style={{ width: '500px', margin: '0 auto' }}>\r\n      <Alert color=\"danger\">\r\n        <h4 className=\"alert-heading\">Oops!</h4>\r\n        <p>\r\n          {message}\r\n        </p>\r\n      </Alert>\r\n    </div>\r\n  )\r\n}\r\n\r\ninterface Props {\r\n  message: string\r\n}\r\n\r\nexport default Error;","import { useMaze } from \"../hooks/useMaze\";\r\nimport { Dimensions, Direction } from \"../types\";\r\nimport { useEffect, useState } from \"react\";\r\nimport { generateEmptyMaze, generateMaze } from \"../utils\";\r\nimport PickerCell from \"./PickerCell\";\r\nimport { PickerCell as PickerCellType } from \"../types\";\r\nimport Error from './Error';\r\n\r\nconst MazePicker: React.FC<Props> = ({ mazeDimensions }) => {\r\n  const [outerMaze, setOuterMaze] = useState<any[][]>([])\r\n\r\n  useEffect(() => {\r\n    if (mazeDimensions && mazeDimensions.height >= 2 && mazeDimensions.width >= 2) {\r\n      setOuterMaze(generateEmptyMaze(mazeDimensions.width + 2, mazeDimensions.height + 2))\r\n    }\r\n  }, [mazeDimensions])\r\n\r\n  const generateMaze = () => {\r\n    return (\r\n      <div style={{ width: `${(mazeDimensions!.width + 2) * 23}px`, margin: '0 auto' }}>\r\n        {\r\n          outerMaze.map((row, i) => {\r\n            if (i === 0) {\r\n              return (\r\n                <div>\r\n                  {\r\n                    row.map((cell, i) => {\r\n                      if (i === 0) {\r\n                        return <PickerCell type={PickerCellType.Corner} />\r\n                      }\r\n                      else if (i === mazeDimensions!.width + 2 - 1) {\r\n                        return <PickerCell type={PickerCellType.Corner} />\r\n                      }\r\n                      else {\r\n                        return (\r\n                          <PickerCell point={{ y: 0, x: i - 1, openDirection: Direction.Up }} type={PickerCellType.Opening} />\r\n                        )\r\n                      }\r\n                    })\r\n                  }\r\n                </div>\r\n              )\r\n            }\r\n            else if (i === mazeDimensions!.height + 2 - 1) {\r\n              return (\r\n                <div>\r\n                  {\r\n                    row.map((cell, i) => {\r\n                      if (i === 0) {\r\n                        return <PickerCell type={PickerCellType.Corner} />\r\n                      }\r\n                      else if (i === mazeDimensions!.width + 2 - 1) {\r\n                        return <PickerCell type={PickerCellType.Corner} />\r\n                      }\r\n                      else {\r\n                        return (\r\n                          <PickerCell point={{ y: mazeDimensions!.height - 1, x: i - 1, openDirection: Direction.Down }} type={PickerCellType.Opening} />\r\n                        )\r\n                      }\r\n                    })\r\n                  }\r\n                </div>\r\n              )\r\n            }\r\n            else\r\n              return (\r\n                <div>\r\n                  {\r\n                    row.map((cell, j) => {\r\n                      if (j === 0) {\r\n                        return <PickerCell point={{ y: i - 1, x: 0, openDirection: Direction.Left }} type={PickerCellType.Opening} />\r\n                      }\r\n                      else if (j === mazeDimensions!.width + 2 - 1) {\r\n                        return <PickerCell point={{ y: i - 1, x: mazeDimensions!.width - 1, openDirection: Direction.Right }} type={PickerCellType.Opening} />\r\n                      }\r\n                      else {\r\n                        return (\r\n                          <PickerCell type={PickerCellType.Filler} />\r\n                        )\r\n                      }\r\n                    })\r\n                  }\r\n                </div>\r\n              )\r\n          })\r\n        }\r\n\r\n      </div>\r\n    )\r\n  }\r\n\r\n  return (\r\n    <>\r\n      {\r\n        mazeDimensions && mazeDimensions.height >= 2 && mazeDimensions.width >= 2\r\n          ? generateMaze()\r\n          : <Error message=\"Maze dimensions have to be at least 2x2.\" />\r\n      }\r\n    </>\r\n  )\r\n}\r\n\r\ninterface Props {\r\n  mazeDimensions?: Dimensions\r\n}\r\n\r\nexport default MazePicker;","import { useContext, useEffect } from \"react\";\r\nimport { SelectedCellsContext } from \"../providers/SelectedCellsProvider\";\r\nimport Maze from \"./Maze\";\r\nimport MazePicker from \"./MazePicker\";\r\n\r\nconst MazeContainer = ({ mazeDimensions }) => {\r\n  const { points } = useContext(SelectedCellsContext)\r\n\r\n  const [start, exit] = points;\r\n\r\n  return (\r\n    <>\r\n      {\r\n        points.length !== 2\r\n          ? <MazePicker {...{ mazeDimensions }} />\r\n          // : null\r\n          : <Maze {... { mazeDimensions, start, exit }} />\r\n      }\r\n    </>\r\n  )\r\n}\r\n\r\nexport default MazeContainer;","import React, { useEffect, useState } from 'react';\r\nimport MazePicker from './components/MazePicker';\r\nimport { useMaze } from './hooks/useMaze';\r\nimport { Dimensions, Direction } from './types';\r\nimport { Button, Input, InputGroup, InputGroupAddon, InputGroupText } from 'reactstrap'\r\nimport SelectedCellsProvider from './providers/SelectedCellsProvider';\r\nimport GenerationButton from './components/GenerationButton';\r\nimport MazeContainer from './components/MazeContainer';\r\n\r\nfunction App() {\r\n  const [width, setWidth] = useState(15);\r\n  const [height, setHeight] = useState(15);\r\n  const [mazeDimensions, setMazeDimensions] = useState<Dimensions>()\r\n\r\n  useEffect(() => {\r\n    setMazeDimensions({\r\n      width, height\r\n    })\r\n  }, [width, height])\r\n\r\n  return (\r\n    <div>\r\n      <div style={{ width: '500px', margin: '25px auto' }}>\r\n        <InputGroup className=\"my-4\">\r\n          <InputGroupAddon addonType=\"prepend\" >\r\n            <InputGroupText>Width</InputGroupText>\r\n          </InputGroupAddon>\r\n          <Input value={width} onChange={(e) => setWidth(+e.target.value)} />\r\n        </InputGroup>\r\n        <InputGroup className=\"my-4\">\r\n          <InputGroupAddon addonType=\"prepend\">\r\n            <InputGroupText>Height</InputGroupText>\r\n          </InputGroupAddon>\r\n          <Input value={height} onChange={(e) => setHeight(+e.target.value)} />\r\n        </InputGroup>\r\n        {/* <Button className=\"w-100\" type=\"submit\" onClick={showMazePicker}>Generate</Button> */}\r\n      </div>\r\n      <SelectedCellsProvider>\r\n        <MazeContainer {...{ mazeDimensions }} />\r\n        {/* <div style={{ width: '500px', margin: '25px auto' }}>\r\n          <GenerationButton />\r\n        </div> */}\r\n      </SelectedCellsProvider>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}